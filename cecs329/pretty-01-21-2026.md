## Key Concepts

- **Formal languages**: A set of all strings - connects to understanding what strings are allowed in programming languages like Python
- **Language hierarchy**: Formal languages can be categorized into different types:
  - Recursively enumerable (Type 0)
  - Context sensitive (Type 1)
  - Context free (Type 2)
  - Regular languages (Type 3)
- **Computability**: The study of what a Turing machine can and cannot do
- **P vs NP problem**: One of the biggest open problems in computer science
  - **P (Polynomial time)**: Problems where a deterministic algorithm can find a solution in polynomial time ("solvable fast")
    - Examples: Sorting a list, shortest path in a graph, matrix multiplication
    - Polynomial time scales well; exponential doesn't
  - **NP (Nondeterministic Polynomial time)**: Problems where finding a solution might be hard, but verifying a candidate solution can be done quickly ("verifiable fast")
    - Examples: Sudoku (general case), Traveling Salesperson (decision version), Boolean satisfiability (SAT)
    - Key idea: Checking is easy, finding might not be
  - **The question**: Is P = NP? (Does every problem whose solution can be verified quickly also have a fast solution?)
  - **Current belief**: Most experts believe P ≠ NP, but this remains unproven
- **Big O notation**: Used to describe algorithmic complexity
- **Set theory foundations**: Relations, functions, and cardinality are important prerequisites


---

## TODOs

- Review set theory concepts: relations, functions, cardinality
- Understand why language types (Type 0-3) are significant
- Clarify why we use "O of n" notation instead of just "n" for complexity analysis


---

## Summary

Introduction to CECS329 covering formal languages and computability theory. Explored the connection between programming languages (like Python) and formal languages, which are sets of all possible strings. Introduced the Chomsky hierarchy of language types (Type 0-3: recursively enumerable, context sensitive, context free, and regular languages). Discussed computability in terms of what Turing machines can and cannot do.

Deep dive into the P vs NP problem, one of the biggest open questions in computer science. P represents problems solvable quickly in polynomial time (like sorting, shortest path, matrix multiplication), while NP represents problems where solutions can be verified quickly but finding them might be hard (like Sudoku, Traveling Salesperson, SAT). The fundamental question is whether P = NP - if every verifiable-fast problem can also be solved fast. Most experts believe P ≠ NP, but this remains unproven. Emphasized the importance of set theory foundations (relations, functions, cardinality) for understanding the course material.


---

## Review Questions



---

## Questions & Things to Look Up

- Why are the language types (Type 0-3) significant? What makes them important?
- Why do we call it "Big O" or "O of n" instead of just saying "n"? What is the importance of this notation?
- Review set theory concepts: relations, functions, cardinality (need to clarify understanding)


---

## Connections & Big Picture

- Formal languages provide the theoretical foundation for understanding what strings are valid in programming languages
- The Chomsky hierarchy (Type 0-3) organizes languages by their computational complexity and the types of automata needed to recognize them
- Computability theory establishes fundamental limits on what can be computed
- Complexity theory (P vs NP) extends computability to questions about efficiency and whether verification and solution-finding have the same difficulty
- The P vs NP question has profound implications: if P = NP, many currently hard problems would become tractable, affecting cryptography, optimization, and many other fields
- Set theory provides the mathematical foundation for all of these concepts


---

## Important Definitions

