## Key Concepts

- **Deterministic world**: Predictable systems (e.g., f=ma, simple programs like `if x > 5 return true`)
- **Stochastic world**: Real-world systems with uncertainty (ping, stock prices, latency, packet loss)
- **Probability as engine** for three main areas:
  - Uncertainty management (AI, sensors, networks)
  - Algorithm design (randomization makes things faster)
  - System analysis (e.g., "will my server crash?")
- **Naive probability**: P(E) = size of event E / size of sample space Ω
  - Hard part is finding the size of Ω
  - Calculating Ω is a counting problem; for large spaces, need combinatorics
- **Sum rule (OR)**: For mutually exclusive events
- **Product rule (AND/sequential)**: For sequential steps (must do step 1 first, then step 2)
  - Step 1 done in n₁ ways, step 2 done in n₂ ways → total is n₁ × n₂
- **Combinatorial explosion**: Too many choices, so brute force doesn't work
- **Order + Replacement allowed → Tuples**: n^k where n is choices per slot, k is length
  - Example: bits can have replacement (1 in one slot, then 1 again in another)
- **Order + NO replacement → Permutations**: P(n,k) = n!/(n-k)!
  - Example: arrange 1st, 2nd, 3rd place for students a, b, c, d, e → 5 × 4 × 3 = 60 ways
  - (n-k)! is the factorial of what we didn't select

---

## TODOs

- DO PRACTICE PROBLEM ON ORDER + REPLACEMENT (super important)

---

## Summary

Transition from deterministic to stochastic world. Probability is the engine for uncertainty management (AI, sensors, networks), algorithm design (randomization for speed), and system analysis (reliability questions).

Naive probability: P(E) = size of event E / size of sample space Ω. Finding Ω is a counting problem requiring combinatorics.

Combinatorics basics:
- **Sum rule**: For OR operations (mutually exclusive events)
- **Product rule**: For AND/sequential operations (multiply ways for each step)

Two key counting scenarios:
1. **Order + Replacement allowed** → Tuples: n^k (e.g., bits, where replacement is allowed)
2. **Order + NO replacement** → Permutations: P(n,k) = n!/(n-k)! (e.g., arranging positions)

Format example: 1 digit, 3 letters, 3 digits → multiply (10 × 26 × 26 × 26 × 10 × 10 × 10) because it's sequential "and then" requirements, not "or" choices.

---

## Review Questions

<!-- Questions to test understanding (to be generated during cleanup) -->

---

## Questions & Things to Look Up

- When selecting samples, what's the difference in how we handle if ordering matters vs. if replacement is allowed?
- Practice problems on order + replacement scenarios

---

## Connections & Big Picture

Moving from deterministic world (predictable physics, simple programs) to stochastic world (real-world systems with uncertainty: network latency, stock prices, packet loss). Probability is fundamental for modern computing systems—AI systems deal with sensor uncertainty, randomized algorithms improve performance, and system reliability analysis requires probabilistic thinking.

Combinatorial explosion shows why brute force fails for large problems—need efficient counting methods (combinatorics) rather than enumerating all possibilities.
