## Key Concepts

- **Generating permutations via recursion (decrease-and-conquer)**:
  - Pick an element \(x\) to be the first element (“head”)
  - Recursively generate permutations of the remaining elements \(S - \{x\}\)
  - Prefix \(x\) to each result
  - Repeat for every possible choice of \(x\)
- **Backtracking view** (same idea, different wording):
  - Choose an option
  - Recurse on the remaining options
  - Undo the choice (pop) and try the next path
- **Base case**: when there are no remaining options, record the current path (copy it).
- **Implementation detail**: avoid mutating `remaining_options` while iterating; one simple approach is to pass a new “remaining” list each recursive call.
- **Why “just moving an index” can be wrong**: advancing `i` (like `dfs(i+1)`) tends to generate **subsets/combinations**; permutations need “try any unused element next”, so you typically track what’s already used.

```python
def generate_permutations(elements):
    results = []

    def backtrack(current_path, remaining_options):
        if len(remaining_options) == 0:
            results.append(current_path.copy())
            return

        for i in range(len(remaining_options)):
            item = remaining_options[i]
            current_path.append(item)
            backtrack(
                current_path,
                remaining_options[:i] + remaining_options[i + 1 :],
            )
            current_path.pop()

    backtrack([], elements)
    return results
```

---

## TODOs

- **Practice**: do a LeetCode permutation problem to reinforce the backtracking pattern.
- **Compare approaches**: try implementing the `used[]` (or set) method and compare it to the “remaining options” slicing method.

---

## Summary

Today covered generating permutations using recursion. The main pattern is “pick a head, recurse on the rest,” which is equivalent to classic backtracking: build a path, recurse, then undo and try the next option. A key takeaway is that permutations require tracking which elements are already used (or explicitly passing “remaining options”), unlike subset-generation patterns that advance an index.

---

## Review Questions

---

## Questions & Things to Look Up

- **What’s the clean “index/used[]” way to do permutations?**
- **Why does `dfs(i+1)` naturally lead to subsets, not permutations?**
- **Tradeoffs**: “remaining options slicing” vs mutating a list + tracking `used` (clarity vs performance).

---

## Connections & Big Picture

- This is the same backtracking template used in many interview/LeetCode problems: choose → recurse → undo.
