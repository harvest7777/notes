## Key Concepts

- **Tail Recursion**: In Haskell, tail recursion occurs when the recursive call is the last operation that returns a value. The tail call gets optimized to a loop, making it the closest thing to a loop in Haskell.
- **`where` Keyword**: Creates local variable/function definitions with scope limited to the left-hand side. The definition is on the right, and from outside the function, you can't see the locally defined functions.
- **Currying**: Every function in Haskell essentially takes one argument. Multi-argument functions are automatically curried into a chain of single-argument functions. This allows for partial application and function chaining.
- **Type Annotations vs Declarations**: In Haskell, type annotation (`seven :: Int`) and value assignment (`seven = 7`) are separate, unlike C where `int seven = 7;` does both in one line.
- **Function Type Signatures**: Haskell function types are right-associative (`Float -> Float -> Float` means `Float -> (Float -> Float)`), reflecting the curried nature of functions.
- **Associativity**: Left associativity means we drop left parentheses (e.g., `(a-b)-c = a-b-c`). Right associativity means we drop right parentheses. Haskell function application is left-associative (`(average a) b`).

---

## TODOs

- Be able to explain every single line in `BasicLanguageConstructs.c` and `BasicLanguageConstructs.hs` - will definitely be tested on this

---

## Summary

This lecture covered several fundamental Haskell concepts:

**Tail Recursion**: Explored how to recognize tail recursion using the factorial example with an accumulating parameter. The key insight is that when the recursive call is the last operation that returns a value, it can be optimized to a loop.

**Local Definitions**: Learned about the `where` keyword for creating local function definitions that are scoped to the function they're defined in.

**Currying**: Deep dive into how currying works in Haskell. Every function essentially takes one argument, and multi-argument functions are automatically curried. This enables partial application (e.g., `h = xxx 3` creates a new function) and function chaining.

**Type System**: Compared Haskell's type annotations (separate from value assignment) with C's combined declaration and assignment. Explored function type signatures and how they reflect the curried nature of Haskell functions.

**Associativity**: Discussed left vs right associativity, particularly how Haskell function types are right-associative while function application is left-associative.

---

## Review Questions

<!-- Questions to test understanding (to be generated during cleanup) -->

---

## Questions & Things to Look Up

- Why is `average a b` left-associative for function application when function types are right-associative?

---

## Connections & Big Picture

- Tail recursion is Haskell's way of achieving iterative behavior without explicit loops, similar to how loops work in imperative languages but expressed functionally.
- Currying is fundamental to Haskell's design and enables powerful functional programming patterns like partial application and function composition.
- The separation of type annotations from value assignments reflects Haskell's emphasis on type safety and allows for more flexible type inference.
- Understanding associativity is crucial for reading and writing Haskell code correctly, especially when dealing with function types and applications.

---

## Important Definitions

- **Type**: In Haskell, types are similar to classes in OOP - they define the structure and behavior of data.
- **Type Annotation**: A declaration that specifies the type of a value or function (`seven :: Int`).
- **Declaration**: Stating what type something is without assigning a value.
- **Currying**: The process of transforming a function that takes multiple arguments into a sequence of functions that each take a single argument.
- **Tail Recursion**: A form of recursion where the recursive call is the last operation that returns a value, allowing for optimization to a loop.
- **Associativity**: The rule that determines how parentheses are dropped when operators or functions are chained together. Left-associative means operations group from the left, right-associative means they group from the right.
