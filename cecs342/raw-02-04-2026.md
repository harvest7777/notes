how do we recognie tail rersion in haskell?

-- Factorial with accumulating parameter
factorial3 n = fact_acc n 1
  where
    fact_acc 0 f = f
    fact_acc n f = fact_acc (n-1) (n * f)

the where keyword makes a local varaible with the scope on the left, def on the right 

you define the function locally with where so from the outside you cnat see it

the only recursive call that retunrs, the value immediately goes right out
the tasil call gets optimzied to a loop
big idea: this line is the closest youll get to a loop in haskell
    fact_acc n f = fact_acc (n-1) (n * f)


todo: be able toe sxxplain every single line in basic language constructs c and hs
we will defintiely be tested on this
ggs


twice2 = \n -> 2 * n

-- wtf does this do
twice3 = (2*) 

fuck a b = a+b

-- what it actually does
fuckcurried a = \b -> (a+b) 
-- lets go asnother alyer down

haha = \a -> (\b -> (a+b))

h = fuck 3

what curried applciations do you can bsically chain that shi together
thats pretty cool
every function in haskell basically got one argument


definition stuff
what is a type?
in oop theyre classes

u can hav etype annotation in haskell
seven :: Int  <- declaration
seven = 7 <- assigning a value

vs in c you do it all in one lien
int seven = 7; <- does boht in once

ex: in c you got a function
the fact this sis a fuctnino that dosees int -> int is bundle togther
int twice(int n) { 
  return 2* n;
}

haskell :
twice :: Int -> Int

c:
int twice(int);

average :: Float -> Float -> Float

(a + b) + c = a+(b+c)  = a + b + c this is a semantic fo addition (a real math property)
this is synattic of subtraction
left associatiive => the name for the rule on how we drop left paranethesis
(a-c) - c = a - b - c
for haskell its RIGHT associative
average :: Float -> (Float -> Float)

this one is left associative tho.. for the average a b ðŸ¤”
(average a) b = (a+b)/2

idk why